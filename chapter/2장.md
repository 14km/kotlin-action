# 코틀린 기초

- 함수, 변수, 클래스, enum, 프로터티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기

## 기본 요소: 함수와 변수

```kotlin
fun main(args: Array<String>) {
    println("Hello, World!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다. 실제로도 코틀린 프로그래밍은 수많은 fun을 만드는 재미있는 일이다!
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다.(자바와 달리) 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- ...

### 함수의 기본 구조

- 코틀린 if는 문장이 아니고 결과를 만드는 식이라는 점이 흥미롭다.
- 이 예제의 코틀린 if식은 자바 3항 연산자로 작성한 `(a > b) ? a : b` 식과 비슷하다.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

> 문(statement)과 식(expression)의 구분
> > 코틀린에서 if는 식이지 문이 아니다. </br>
> > 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면에 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.

### 식이 본문인 함수

- 조금 전에 살펴본 함수를 더 간결하게 표현할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라 부르고, 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.
  (인텔리J 팁 -> 서로 변환하는 메뉴가 존재한다.)

- 아래와 같이 반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

- 반환 타입을 생략할 수 있는 이유는 **컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소를 타입을 정해주는 기능을 _타입추론_ 이라 부른다.**
- 단, 식이 본문인 함수의 반환 타입만 생략이 가능하다는 점을 유의하라.

## 변수

- 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다.
- 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.

```kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42

// 이 예제에서는 타입 표기를 생략했지만 원한다면 타입을 명시해도 된다.
val answer: Int = 42
```

- 초기화 식을 사용하지 않고 선언하려면 변수 타입을 반드시 명시해야한다.

```kotlin
val answer: Int
answer = 42
```

### 변경 가능한 변수와 변경 불가능한 변수

- 변수 선언 시 사용하는 키워드는 다음과 같은 2가지가 있다.

> **val**(값을 뜻하는 value에서 따옴) - 변경 불가능한(immutable) 참조를 저장하는 변수다.

> **var**(변수를 뜻하는 variable에서 따옴) - 변경 가능한(mutable) 참조다.

- `기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하라.`

- val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하라.

```kotlin
val languages = arrayListOf("Java") // 불변 참조를 선언한다.
languages.add("Kotlin") // 참조가 가리키는 객체 내부를 변경한다.
```

### 더 쉽게 문자열 형식 지정: 문자열 템플릿

- 아래의 예제 문자열 템플릿 이라는 기능을 보여준다.

```kotlin
fun main(array: Array<String>) {
    val name = if (array.isNotEmpty()) array[0] else "NoName"
    println("Hello, $name")
}
```

- 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 `$`를 추가해야 한다.
- 복잡한 식도 중괄호(`{}`)로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.

```kotlin
fun main(array: Array<String>) {
    if (array.isNotEmpty()) {
        println("Hello, ${array[0]}")
    }
}
```

## 클래스와 프로퍼티

- 시작하기 위해 간단한 자바빈(JavaBean) 클래스인 Person을 정의하자. Person에는 name이라는 프로퍼티만 들어있다.

```java
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
```

- 코틀린과 비교해본다.

```kotlin
class Person(val name: String)
```

- 멋지다. 이런 유형의 클래스(코드가 없이 데이터만 저장하는 클래스)를 **값 객체(Value Object)** 라 부르며, 다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.

### 프로퍼티

- 클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.
- 클래스에서 프로퍼티를 선언할 때는 앞에서 살펴본 변수를 선언하는 방법과 마찬가지로 val이나 var를 사용한다.
- **val** 로 선언한 프로퍼티는 읽기 전용이며, **var** 로 선언한 프로퍼티는 변경 가능하다.

```kotlin
class Person(
    val name: String,           // 읽기 전용 프로퍼티
    var isMarried: Boolean      // 쓸 수 있는 프로퍼티
)
```

- 코틀린에서 프로퍼티 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다.

> 읽기 전용 프로퍼티의 경우(val) getter만 선언하며 변경할 수 있는 프로퍼티(var)의 경우 getter와 setter를 모두 선언한다.)

- 커스텀 접근자로 아래와 같이 커스텀한 값을 판단 가능한 로직을 추가할 수 있다.

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}

// ------
val rectangle = Rectangle(41, 43)
println(rectangle.isSquare)     // false
```

### 다른 패키지에 있는 함수 import 하기

```kotlin
package common.example

import common.test.create   // 이름으로 함수 import 하기

fun main(args: Array<String>) {
    println(create().isCreate)  // "ture"가 생상된다.
}
```

- 패키지 이름 뒤에 .*를 추가하면 패키지 안의 모든 선언을 임포트 할 수 있다.
- 모든 클래스뿐만 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러와질 수 있다.

## 선택 표현과 처리 : enum 과 when

- when은 자바의 switch를 대치하되 훨씬 더 강력하다.

### enum 클래스 정의

- 색을 표현하는 enum을 표현해보자
- 코틀린에서는 enum class를 사용하지만 자바에서는 enum을 사용한다.
- 코틀린에서 enum은 `소프트 키워드`라 부르는 존재다.

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```

### 프로퍼티와 메소드가 있는 enum 클래스 선언하기

```kotlin
enum class Color(
    val r: Int, val g: Int, val b: Int
) {
    RED(255, 0, 0), ORANGE(255, 165, 0),
    YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
    INDIGO(75, 0, 130), VIOLET(238, 130, 238);

    fun rgb() = (r * 256 + g) * 256 + b;
}

// 255
println(Color.BLUE.rgb())
```

- enum에서도 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다.
- enum class 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야한다.

### when으로 enum 클래스 다루기

- if와 마찬가지로 when도 값을 만들어내는 식이다.
- 따라서 식이 본문인 함수에 when을 바로 사용할 수 있다.

```kotlin
fun getMnemonic(color: Color) =
    when (color) {
        Color.RED -> "Richard"
        Color.ORANGE -> "OF"
        Color.YELLOW -> "York"
        Color.GREEN -> "Gave"
        // ...
    }

println(getMnemonic(Color.YELLOW))
// York
```

- 또한, 아래와 같이 한 분기 안에서 여러값을 매치 패턴으로 사용할 수도 있다. </br> 그럴 경우 값 사이를 콤마(,)로 분리한다.

```kotlin
fun getWarmth(color: Color) =
    when (color) {
        Color.RED, Color.ORANGE -> "Good"
        Color.YELLOW, Color.GREEN -> "Gave"
        // ...
    }

println(getWarmth(Color.YELLOW))
// Gave
```

#### enum 상수 값을 임포트해서 enum 클래스 수식자 없이 enum 사용하기

- 상수 값을 import하면 이 코드를 더 간단하게 만들 수 있다.

```kotlin
import colors.Color // 다른 패키지에서 import 시킴
import colors.Color.* // 짧은 이름을 사용하기 위해서 모두 import 시키는 경우

fun getWarmth(color: Color) = when (color) {
    RED, ORANGE, WELLOW -> "warm"
    GREEN -> "neutral"
    BLUE, INDIGO, VIOLET -> "cold"
}
```

### when과 임의의 객체를 함께 사용하기

- 분기 조건에 상수(enum 상수나 숫자 리터럴)만을 사용할 수 있는 자바 switch와 달리 코틀린 when의 분기 조건은 임의의 객체를 허용한다.

```kotlin
fun mix(c1: Color, c2: Color) =
// when 식의 인자로 아무 객체나 사용이 가능하다.
    // when은 이렇게 인자로 받은 객체가 각 분기 조건에 있는 개체와 같은지 테스트한다.
    when (setOf(c1, c2)) {
        setOf(RED, YELLOW) -> ORANGE
        setOf(YELLOW, BLUE) -> GREEN
        setOf(BLUE, VIOLET) -> INDIGO
        else -> throw Exception("Dirty Color")
    }

println(mix(BLUE, YELLOW))
// GREEN
```

- c1과 c2가 RED와 YELLOW라면 그 둘은 혼합한 결과는 ORANGE다.
- 객체들을 포함하는 집합인 Set 객체로 만드는 setOf라는 함수가 있다. (집합은 원소가 모여 있는 컬렉션으로, 각 원소의 순서는 중요하지 않다.)
- 따라서, setOf(c1, c2)와 set(RED, YELLOW)가 같다는 말은 c1이 RED이고 c2가 YELLOW거나, c1이 YELLOW이고 c2가 RED라는 말이다.
- when 식은 인자 값과 매치하는 조건 값을 찾을 때 까지 각 분기를 검사한다.

### 인자 없는 when 사용

- 인자가 없는 when 식을 사용하면 불필요한 객체 생성을 막을 수 있다.
- 코드는 약간 읽기 어려워지지만 성능을 더 향상시키기 위해 그정도 비용을 감수해야 하는 경우도 자주 있다.

```kotlin
fun mixOptimized(c1: Color, c2: Color) =
    when {
        (c1 == RED && c2 == YELLOW) || (c1 == YELLOW && c2 == RED) -> ORANGE
        (c1 == YELLOW && c2 == BLUE) || (c1 == BLUE && c2 == YELLOW) -> GREEN
        (c1 == BLUE && c2 == VIOLET) || (c2 == VIOLET && c2 == BLUE) -> INDIGO
        else -> thorw Exception ("Dirty Color")
    }

println(mixOptimized(BLUE, YELLOW))
// GREEN
```

- when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.
- 추가 객체를 만들지 않는다는 장점이 있지만 가독성은 더 떨어진다.

### 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

- (1+2)+4와 같은 간단한 산술식을 계산하는 함수를 만들어보자.
- 우선 식을 인코딩하는 방법을 생각해야 한다. 식을 트리구조로 구성하자.
- 노드는 합계(sum)나 수(num)중 하나다. Num은 항상 말단(leaf 또는 terminal)노드지만, Sum은 자식이 둘 있는 중간(non-terminal)노드다.

```kotlin
interface Expr

// value라는 프로퍼티만 존재하는 단순한 클래스로 Expr 을 구현한다.
class Num(val value: Int) : Expr

// Expr 타입의 객체라면 어떤 것이나 Sum 연산의 인자가 될 수 있다.
class Sum(val left: Expr, val right: Expr) : Expr
```

- (1 + 2) + 4 라는 식을 저장하면 Sum(Sum(Num(1), Num(2)), Num(4)) 라는 구조의 객체가 생긴다.
