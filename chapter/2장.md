# 코틀린 기초

- 함수, 변수, 클래스, enum, 프로터티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기

## 기본 요소: 함수와 변수

```kotlin
fun main(args: Array<String>) {
    println("Hello, World!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다. 실제로도 코틀린 프로그래밍은 수많은 fun을 만드는 재미있는 일이다!
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다.(자바와 달리) 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- ...

### 함수의 기본 구조

- 코틀린 if는 문장이 아니고 결과를 만드는 식이라는 점이 흥미롭다.
- 이 예제의 코틀린 if식은 자바 3항 연산자로 작성한 `(a > b) ? a : b` 식과 비슷하다.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

> 문(statement)과 식(expression)의 구분
> > 코틀린에서 if는 식이지 문이 아니다. </br>
> > 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면에 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.

### 식이 본문인 함수

- 조금 전에 살펴본 함수를 더 간결하게 표현할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라 부르고, 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.
(인텔리J 팁 -> 서로 변환하는 메뉴가 존재한다.)

- 아래와 같이 반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```
- 반환 타입을 생략할 수 있는 이유는 **컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소를 타입을 정해주는 기능을 _타입추론_ 이라 부른다.** 
- 단, 식이 본문인 함수의 반환 타입만 생략이 가능하다는 점을 유의하라.

## 변수
- 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다.

```kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42

// 이 예제에서는 타입 표기를 생략했지만 원한다면 타입을 명시해도 된다.
val answer: Int = 42
```
