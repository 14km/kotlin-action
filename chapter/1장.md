# 코틀린이란 무엇이며, 왜 필요한가?

- JVM 플랫폼에서 돌아가는 프로그래밍 언어
- 코틀린은 간결하고 실용적이며, 자바 코드와 상호운용성을 중시한다.
- 코틀린은 정적 타입 지정언어 이다.
    - 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있다.
    - 객체의 필드나 메소드를 사용할 때 마다 검증을 해준다.
- 코틀린의 빌더 패턴을 활용하면 간결한 구문을 사용해 객체로 이뤄진 그래프를 쉽게 구축하면서도 코틀린이 제공하는 완전한 추상화와 코드 재활용을 지속적으로 누릴 수 있다.

---

## 타입 추론의 장점

- **성능** : 실행 시점에 어떤 메소드가 호출할지 알아내는 과정이 필요없다. (메소드 호출이 빠름)
- **신뢰성** : 컴파일러가 프로그램의 정확성을 검증하기 떄문에 실행시 프로그램 오류로 중단될 가능성이 적다.
- **유지 보수성** : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- **도구 지원** : 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있다.

---

## 함수형 프로그래밍의 핵심 개념

- <b>일급시민인 함수</b> : 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
- <b>불변성</b> : 함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용하여 작성한다.
- <b>부수효과 없음</b> : 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상화작용하지 않는 순수함수를 사용한다.

### 비슷한 작업의 두 코드

- 두 코드 조각은 일부 요구조건이 차이가 난다. (예를 들어 만족 시켜야하는 조건이 서로 다름)
- 공통 부분을 따로 함수로 뽑아내고 세부적인 다른 사항을 인자로 전달할 수 있다. (이런 인자는 그 자체가 함수다.)

```kotlin
fun findAlice() == findPerson { it.name == "Alice" }
fun findConnor() == findPerson { it.name == "Connor" }
```

### 다중 스레드에도 안전하다.

- 불변 데이터 구조를 사용하고 순수 함수를 그 데이터 구조에 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다.

### 테스트 하기가 쉽다.

- 부수효과가 있는 함수는 그 함수를 실행할 때 필요한 전체 환경을 구성하는 준비코드(setup)가 필요하지만, 순수 함수는 그런 준비 코드가 없이 독립적으로 테스트할 수 있다.

---

## 코틀린의 철학

- 코틀린이 자바와 상호운용성에 초점을 맞춘 실용적이고 간결한 안전한 언어라고 설명하는 경우가 자주 있다.
- 그렇다면 실용성, 간결성, 안정성, 상호운용성은 각각 어떤 뜻일까?

### 실용성

- 코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어이다.
- 코틀린은 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다.
- 이로 인해 언어의 복잡도가 줄어들고 이미 알고 잇는 기존 개념을 통해 코틀린을 조금 더 쉽게 터득할 수 있다.

### 간결성

- 코드가 더 간결하면 쓰는데 시간이 덜 걸린다.
- 더 중요한 것은 읽는 데도 시간이 덜걸린다는 점이다.
- 간결성은 여러분의 생산성을 향상시켜주고 개발을 더 빠르게 진행할 수 있게 해준다.

### 안정성

- 일반적으로 프로그래밍 언어가 안전하다는 말은 프로그램에서 발생할 수 있는 오류중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다는 뜻이다. (물론 이는 절대적이지 않다.)
- 큰 안정성을 얻기 위해서는 프로그램에 더 많은 정보를 덧붙여야 하므로 생산성이 하락하는 것을 감수해야하며 안정성과 생산성 사이에는 트레이드오프(trade off) 관계가 성립한다.

> 트레이드오프(trade off) : 두 개의 정책목표 가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 경우의 양자간의 관계. 


- 가장 중요한 내용으로 코틀린은 프로그램의 NPE(NullPointerException)이 발생할 수 있는 연산을 사용하는 코드를 금지한다.
```
val s: String? = null <- NULL이 될 수 있음
val s2: String = "" <- Null이 될 수 없음
```

### 상호운용성

- 상호운용성과 관련해 자바 프로그래머들이 던지는 첫 번째 질문은 아마도 "기존 라이브러리를 그대로 사용할 수 있느냐?"일 것이다. -> 코틀린에 대한 답은 "물론, 그렇다"
- 라이브러리가 어떤 aPI를 제공하던 간에 코틀린에서 그 API를 활용 할 수 있다.
- 자바 메소드를 호출하거나 자바 클래스를 상속(확장)하거나 인터페이스를 구현하거나 자바 어노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능하다.
- 자바 메소드를 리팩토링해도 그 메소드와 관련 있는 코틀린 코드까지 제대로 변경된다.
역으로 코틀린 메소드를 리팩토링해도 자바 코드까지 모두 자동으로 변경된다.

---

# 코틀린 코드 컴파일
- 코틀린 컴파일러는 자바컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드를 분석해서 .class 파일을 만들어낸다.
